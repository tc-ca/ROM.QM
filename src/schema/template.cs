// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do one of these:
//
//    using TC.PowerApps.Models;
//
//    var template = Template.FromJson(jsonString);
//    var group = Group.FromJson(jsonString);
//    var question = Question.FromJson(jsonString);
//    var dependant = Dependant.FromJson(jsonString);
//    var dependencyGroup = DependencyGroup.FromJson(jsonString);
//    var dependencyGroupItem = DependencyGroupItem.FromJson(jsonString);
//    var comment = Comment.FromJson(jsonString);
//    var responseOption = ResponseOption.FromJson(jsonString);
//    var file = File.FromJson(jsonString);
//    var picture = Picture.FromJson(jsonString);
//    var fileItem = FileItem.FromJson(jsonString);
//    var pictureItem = PictureItem.FromJson(jsonString);
//    var title = Title.FromJson(jsonString);
//    var validationRule = ValidationRule.FromJson(jsonString);
//    var violationInfo = ViolationInfo.FromJson(jsonString);
//    var samplingInfo = SamplingInfo.FromJson(jsonString);
//    var searchableProvision = SearchableProvision.FromJson(jsonString);
//    var questionResponseType = QuestionResponseType.FromJson(jsonString);
//    var comparisonOperator = ComparisonOperator.FromJson(jsonString);
//    var validationRuleType = ValidationRuleType.FromJson(jsonString);
//    var option = Option.FromJson(jsonString);
//    var dependencyGroupType = DependencyGroupType.FromJson(jsonString);
//    var result = Result.FromJson(jsonString);
//    var response = Response.FromJson(jsonString);

namespace TC.PowerApps.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Template
    {
        /// <summary>
        /// list of objects representing groupings of questions in this Template
        /// </summary>
        [JsonProperty("groups")]
        public List<Group> Groups { get; set; }

        /// <summary>
        /// unique id (GUID) of the template
        /// </summary>
        [JsonProperty("guid")]
        public string Guid { get; set; }

        /// <summary>
        /// Static name; think radio button groups
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// if the questionnaire\template is read-only due to the state of the object in dyanmics
        /// </summary>
        [JsonProperty("readOnly")]
        public bool ReadOnly { get; set; }

        /// <summary>
        /// list of objects representing all the associated provisions of this template
        /// and the questions those provisions are linked to
        /// </summary>
        [JsonProperty("searchableProvisions")]
        public List<SearchableProvision> SearchableProvisions { get; set; }

        /// <summary>
        /// title of the element in a multi-lang array
        /// </summary>
        [JsonProperty("title")]
        public Title Title { get; set; }
    }

    public partial class Group
    {
        /// <summary>
        /// unique ID for html element id
        /// </summary>
        [JsonProperty("domId")]
        public string DomId { get; set; }

        /// <summary>
        /// suffix used to create unique html element ids
        /// when repeating groups
        /// </summary>
        [JsonProperty("domSuffix")]
        public string DomSuffix { get; set; }

        /// <summary>
        /// unique id (GUID) of the template
        /// </summary>
        [JsonProperty("guid")]
        public string Guid { get; set; }

        /// <summary>
        /// represents if this group can be repeated by user
        /// </summary>
        [JsonProperty("isRepeatable")]
        public bool IsRepeatable { get; set; }

        /// <summary>
        /// if this group is visible by default
        ///
        /// having a value of false would assume that this group has been included
        /// in a DependencyGroup of a Question which decribes the logic
        /// used to hide or show this group
        /// </summary>
        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        /// <summary>
        /// Static name; think radio button groups.
        /// Also for copy purpose to know its a clone or identify original
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// the set of Questions that belong to this group
        /// </summary>
        [JsonProperty("questions")]
        public List<Question> Questions { get; set; }

        /// <summary>
        /// order in which this group appears in a set of groups of a template
        /// </summary>
        [JsonProperty("sortOrder")]
        public double SortOrder { get; set; }

        /// <summary>
        /// title of the element in a multi-lang array
        /// </summary>
        [JsonProperty("title")]
        public Title Title { get; set; }
    }

    public partial class Question
    {
        /// <summary>
        /// child or sub-questions
        /// </summary>
        [JsonProperty("childQuestions")]
        public List<Question> ChildQuestions { get; set; }

        /// <summary>
        /// the result of this question can affect the
        /// -question requirement,
        /// -enabling of a ValidationRule, or
        /// -setting the value of what a validationRule should validate against
        /// for other questions
        ///
        /// having a dependant also means that this question is included inside
        /// a dependencyGroup of that question
        /// </summary>
        [JsonProperty("dependants")]
        public List<Dependant> Dependants { get; set; }

        /// <summary>
        /// the
        /// -question requirement,
        /// -enabling of a ValidationRule, or
        /// -setting the value of what a validationRule should validate against
        /// for this question can be dependent on other questions as described in
        /// the DependencyGroups of this array
        /// </summary>
        [JsonProperty("dependencyGroups")]
        public List<DependencyGroup> DependencyGroups { get; set; }

        /// <summary>
        /// unique id (GUID) of the template
        /// </summary>
        [JsonProperty("guid")]
        public string Guid { get; set; }

        /// <summary>
        /// represents if this element CAN be repeated by user
        /// </summary>
        [JsonProperty("isRepeatable")]
        public bool IsRepeatable { get; set; }

        /// <summary>
        /// represents if this element HAS been repeated by user
        /// </summary>
        [JsonProperty("isRepeated")]
        public bool IsRepeated { get; set; }

        [JsonProperty("isSamplingAllowed")]
        public bool IsSamplingAllowed { get; set; }

        /// <summary>
        /// if this question is visible by default
        ///
        /// having a value of false would assume that this question has been included
        /// in a DependencyGroup of another Question to decribes the logic
        /// used to hide or show this question
        /// </summary>
        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        /// <summary>
        /// Static name; think radio button groups
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// only radio and select have resonse options...currently -
        /// TODO: every type of Question should have them
        /// </summary>
        [JsonProperty("responseOptions")]
        public List<ResponseOption> ResponseOptions { get; set; }

        [JsonProperty("result")]
        public Result Result { get; set; }

        /// <summary>
        /// order in which this group appears in a set of groups of a template
        /// </summary>
        [JsonProperty("sortOrder")]
        public double SortOrder { get; set; }

        /// <summary>
        /// text of the question in a multi-lang array
        /// </summary>
        [JsonProperty("text")]
        public Title Text { get; set; }

        /// <summary>
        /// what type of question is this
        /// </summary>
        [JsonProperty("type")]
        public QuestionResponseTypeEnum Type { get; set; }

        /// <summary>
        /// array of rules describing what is required for the response
        /// of this question to be valid
        /// </summary>
        [JsonProperty("validationRules")]
        public List<ValidationRule> ValidationRules { get; set; }

        /// <summary>
        /// represents the state of validation for a question
        /// maybe long could make computed, but working
        /// </summary>
        [JsonProperty("validationState")]
        public bool ValidationState { get; set; }
    }

    public partial class Dependant
    {
        [JsonProperty("guid")]
        public string Guid { get; set; }
    }

    public partial class DependencyGroup
    {
        [JsonProperty("childValidatorName")]
        public string ChildValidatorName { get; set; }

        [JsonProperty("questionDependencies")]
        public List<DependencyGroupItem> QuestionDependencies { get; set; }

        [JsonProperty("ruleType")]
        public DependencyGroupTypeEnum RuleType { get; set; }
    }

    public partial class DependencyGroupItem
    {
        [JsonProperty("dependsOnQuestion")]
        public Dependant DependsOnQuestion { get; set; }

        [JsonProperty("validationAction")]
        public ComparisonOperatorEnum? ValidationAction { get; set; }

        [JsonProperty("validationValue")]
        public string ValidationValue { get; set; }
    }

    public partial class ResponseOption
    {
        [JsonProperty("externalCommentRequirement")]
        public OptionEnum ExternalCommentRequirement { get; set; }

        [JsonProperty("fileRequirement")]
        public OptionEnum FileRequirement { get; set; }

        [JsonProperty("guid")]
        public string Guid { get; set; }

        [JsonProperty("internalCommentRequirement")]
        public OptionEnum InternalCommentRequirement { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("pictureRequirement")]
        public OptionEnum PictureRequirement { get; set; }

        [JsonProperty("provisions")]
        public List<string> Provisions { get; set; }

        [JsonProperty("sortOrder")]
        public double SortOrder { get; set; }

        [JsonProperty("text")]
        public Title Text { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// text of the question in a multi-lang array
    ///
    /// title of the element in a multi-lang array
    /// </summary>
    public partial class Title
    {
        [JsonProperty("en")]
        public string En { get; set; }

        [JsonProperty("fr")]
        public string Fr { get; set; }
    }

    public partial class Result
    {
        [JsonProperty("externalComment")]
        public string ExternalComment { get; set; }

        [JsonProperty("files")]
        public File Files { get; set; }

        [JsonProperty("internalComment")]
        public string InternalComment { get; set; }

        [JsonProperty("pictures")]
        public Picture Pictures { get; set; }

        [JsonProperty("responses")]
        public List<Response> Responses { get; set; }

        [JsonProperty("samplingRecord")]
        public SamplingInfo SamplingRecord { get; set; }

        [JsonProperty("violationInfo")]
        public ViolationInfo ViolationInfo { get; set; }
    }

    public partial class File
    {
        [JsonProperty("items")]
        public List<FileItem> Items { get; set; }
    }

    public partial class FileItem
    {
        [JsonProperty("comment")]
        public string Comment { get; set; }

        [JsonProperty("fileName")]
        public string FileName { get; set; }

        [JsonProperty("guid")]
        public string Guid { get; set; }

        [JsonProperty("timeStamp")]
        public DateTimeOffset TimeStamp { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("uploadedBy")]
        public string UploadedBy { get; set; }
    }

    public partial class Picture
    {
        [JsonProperty("items")]
        public List<PictureItem> Items { get; set; }
    }

    public partial class PictureItem
    {
        [JsonProperty("comment")]
        public string Comment { get; set; }

        [JsonProperty("fileName")]
        public string FileName { get; set; }

        [JsonProperty("guid")]
        public string Guid { get; set; }

        [JsonProperty("timeStamp")]
        public DateTimeOffset TimeStamp { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("uploadedBy")]
        public string UploadedBy { get; set; }
    }

    public partial class Response
    {
        [JsonProperty("guid")]
        public string Guid { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class SamplingInfo
    {
        [JsonProperty("approximateTotal")]
        public string ApproximateTotal { get; set; }

        [JsonProperty("sampleSize")]
        public string SampleSize { get; set; }
    }

    public partial class ViolationInfo
    {
        [JsonProperty("referenceID")]
        public string ReferenceId { get; set; }

        [JsonProperty("violationCount")]
        public string ViolationCount { get; set; }
    }

    public partial class ValidationRule
    {
        [JsonProperty("enabled")]
        public bool Enabled { get; set; }

        [JsonProperty("errorMessage")]
        public Title ErrorMessage { get; set; }

        [JsonProperty("name")]
        public ValidationRuleTypeEnum Name { get; set; }

        [JsonProperty("type")]
        public ValidationRuleTypeEnum Type { get; set; }

        [JsonProperty("value")]
        public Value Value { get; set; }
    }

    public partial class SearchableProvision
    {
        [JsonProperty("leg")]
        public string Leg { get; set; }

        [JsonProperty("questions")]
        public List<string> Questions { get; set; }
    }

    public partial class Comment
    {
        [JsonProperty("option")]
        public OptionEnum Option { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public enum ComparisonOperatorEnum { Equal, GreaterThen, LengthGreaterThen, LengthLessThen, LessThen, NotEqual };

    public enum DependencyGroupTypeEnum { Validation, ValidationValue, Visibility };

    public enum OptionEnum { NA, Optional, Required };

    public enum QuestionResponseTypeEnum { Number, Radio, Reference, Select, Text };

    public enum ValidationRuleTypeEnum { Max, MaxLength, Min, MinLength, Require };

    public partial struct Value
    {
        public double? Double;
        public string String;

        public static implicit operator Value(double Double) => new Value { Double = Double };
        public static implicit operator Value(string String) => new Value { String = String };
        public bool IsNull => Double == null && String == null;
    }

    public partial class Template
    {
        public static Template FromJson(string json) => JsonConvert.DeserializeObject<Template>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Group
    {
        public static Group FromJson(string json) => JsonConvert.DeserializeObject<Group>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Question
    {
        public static Question FromJson(string json) => JsonConvert.DeserializeObject<Question>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Dependant
    {
        public static Dependant FromJson(string json) => JsonConvert.DeserializeObject<Dependant>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class DependencyGroup
    {
        public static DependencyGroup FromJson(string json) => JsonConvert.DeserializeObject<DependencyGroup>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class DependencyGroupItem
    {
        public static DependencyGroupItem FromJson(string json) => JsonConvert.DeserializeObject<DependencyGroupItem>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Comment
    {
        public static Comment FromJson(string json) => JsonConvert.DeserializeObject<Comment>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class ResponseOption
    {
        public static ResponseOption FromJson(string json) => JsonConvert.DeserializeObject<ResponseOption>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class File
    {
        public static File FromJson(string json) => JsonConvert.DeserializeObject<File>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Picture
    {
        public static Picture FromJson(string json) => JsonConvert.DeserializeObject<Picture>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class FileItem
    {
        public static FileItem FromJson(string json) => JsonConvert.DeserializeObject<FileItem>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class PictureItem
    {
        public static PictureItem FromJson(string json) => JsonConvert.DeserializeObject<PictureItem>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Title
    {
        public static Title FromJson(string json) => JsonConvert.DeserializeObject<Title>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class ValidationRule
    {
        public static ValidationRule FromJson(string json) => JsonConvert.DeserializeObject<ValidationRule>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class ViolationInfo
    {
        public static ViolationInfo FromJson(string json) => JsonConvert.DeserializeObject<ViolationInfo>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class SamplingInfo
    {
        public static SamplingInfo FromJson(string json) => JsonConvert.DeserializeObject<SamplingInfo>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class SearchableProvision
    {
        public static SearchableProvision FromJson(string json) => JsonConvert.DeserializeObject<SearchableProvision>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public class QuestionResponseType
    {
        public static QuestionResponseTypeEnum FromJson(string json) => JsonConvert.DeserializeObject<QuestionResponseTypeEnum>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public class ComparisonOperator
    {
        public static ComparisonOperatorEnum FromJson(string json) => JsonConvert.DeserializeObject<ComparisonOperatorEnum>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public class ValidationRuleType
    {
        public static ValidationRuleTypeEnum FromJson(string json) => JsonConvert.DeserializeObject<ValidationRuleTypeEnum>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public class Option
    {
        public static OptionEnum FromJson(string json) => JsonConvert.DeserializeObject<OptionEnum>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public class DependencyGroupType
    {
        public static DependencyGroupTypeEnum FromJson(string json) => JsonConvert.DeserializeObject<DependencyGroupTypeEnum>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Result
    {
        public static Result FromJson(string json) => JsonConvert.DeserializeObject<Result>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public partial class Response
    {
        public static Response FromJson(string json) => JsonConvert.DeserializeObject<Response>(json, TC.PowerApps.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Template self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Group self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Question self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Dependant self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this DependencyGroup self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this DependencyGroupItem self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Comment self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this ResponseOption self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this File self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Picture self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this FileItem self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this PictureItem self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Title self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this ValidationRule self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this ViolationInfo self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this SamplingInfo self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this SearchableProvision self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this QuestionResponseTypeEnum self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this ComparisonOperatorEnum self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this ValidationRuleTypeEnum self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this OptionEnum self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this DependencyGroupTypeEnum self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Result self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
        public static string ToJson(this Response self) => JsonConvert.SerializeObject(self, TC.PowerApps.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ComparisonOperatorEnumConverter.Singleton,
                DependencyGroupTypeEnumConverter.Singleton,
                OptionEnumConverter.Singleton,
                QuestionResponseTypeEnumConverter.Singleton,
                ValidationRuleTypeEnumConverter.Singleton,
                ValueConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ComparisonOperatorEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ComparisonOperatorEnum) || t == typeof(ComparisonOperatorEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "equal":
                    return ComparisonOperatorEnum.Equal;
                case "greaterThen":
                    return ComparisonOperatorEnum.GreaterThen;
                case "lengthGreaterThen":
                    return ComparisonOperatorEnum.LengthGreaterThen;
                case "lengthLessThen":
                    return ComparisonOperatorEnum.LengthLessThen;
                case "lessThen":
                    return ComparisonOperatorEnum.LessThen;
                case "notEqual":
                    return ComparisonOperatorEnum.NotEqual;
            }
            throw new Exception("Cannot unmarshal type ComparisonOperatorEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ComparisonOperatorEnum)untypedValue;
            switch (value)
            {
                case ComparisonOperatorEnum.Equal:
                    serializer.Serialize(writer, "equal");
                    return;
                case ComparisonOperatorEnum.GreaterThen:
                    serializer.Serialize(writer, "greaterThen");
                    return;
                case ComparisonOperatorEnum.LengthGreaterThen:
                    serializer.Serialize(writer, "lengthGreaterThen");
                    return;
                case ComparisonOperatorEnum.LengthLessThen:
                    serializer.Serialize(writer, "lengthLessThen");
                    return;
                case ComparisonOperatorEnum.LessThen:
                    serializer.Serialize(writer, "lessThen");
                    return;
                case ComparisonOperatorEnum.NotEqual:
                    serializer.Serialize(writer, "notEqual");
                    return;
            }
            throw new Exception("Cannot marshal type ComparisonOperatorEnum");
        }

        public static readonly ComparisonOperatorEnumConverter Singleton = new ComparisonOperatorEnumConverter();
    }

    internal class DependencyGroupTypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DependencyGroupTypeEnum) || t == typeof(DependencyGroupTypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "validation":
                    return DependencyGroupTypeEnum.Validation;
                case "validationValue":
                    return DependencyGroupTypeEnum.ValidationValue;
                case "visibility":
                    return DependencyGroupTypeEnum.Visibility;
            }
            throw new Exception("Cannot unmarshal type DependencyGroupTypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DependencyGroupTypeEnum)untypedValue;
            switch (value)
            {
                case DependencyGroupTypeEnum.Validation:
                    serializer.Serialize(writer, "validation");
                    return;
                case DependencyGroupTypeEnum.ValidationValue:
                    serializer.Serialize(writer, "validationValue");
                    return;
                case DependencyGroupTypeEnum.Visibility:
                    serializer.Serialize(writer, "visibility");
                    return;
            }
            throw new Exception("Cannot marshal type DependencyGroupTypeEnum");
        }

        public static readonly DependencyGroupTypeEnumConverter Singleton = new DependencyGroupTypeEnumConverter();
    }

    internal class OptionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OptionEnum) || t == typeof(OptionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "n/a":
                    return OptionEnum.NA;
                case "optional":
                    return OptionEnum.Optional;
                case "required":
                    return OptionEnum.Required;
            }
            throw new Exception("Cannot unmarshal type OptionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OptionEnum)untypedValue;
            switch (value)
            {
                case OptionEnum.NA:
                    serializer.Serialize(writer, "n/a");
                    return;
                case OptionEnum.Optional:
                    serializer.Serialize(writer, "optional");
                    return;
                case OptionEnum.Required:
                    serializer.Serialize(writer, "required");
                    return;
            }
            throw new Exception("Cannot marshal type OptionEnum");
        }

        public static readonly OptionEnumConverter Singleton = new OptionEnumConverter();
    }

    internal class QuestionResponseTypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(QuestionResponseTypeEnum) || t == typeof(QuestionResponseTypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "number":
                    return QuestionResponseTypeEnum.Number;
                case "radio":
                    return QuestionResponseTypeEnum.Radio;
                case "reference":
                    return QuestionResponseTypeEnum.Reference;
                case "select":
                    return QuestionResponseTypeEnum.Select;
                case "text":
                    return QuestionResponseTypeEnum.Text;
            }
            throw new Exception("Cannot unmarshal type QuestionResponseTypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (QuestionResponseTypeEnum)untypedValue;
            switch (value)
            {
                case QuestionResponseTypeEnum.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case QuestionResponseTypeEnum.Radio:
                    serializer.Serialize(writer, "radio");
                    return;
                case QuestionResponseTypeEnum.Reference:
                    serializer.Serialize(writer, "reference");
                    return;
                case QuestionResponseTypeEnum.Select:
                    serializer.Serialize(writer, "select");
                    return;
                case QuestionResponseTypeEnum.Text:
                    serializer.Serialize(writer, "text");
                    return;
            }
            throw new Exception("Cannot marshal type QuestionResponseTypeEnum");
        }

        public static readonly QuestionResponseTypeEnumConverter Singleton = new QuestionResponseTypeEnumConverter();
    }

    internal class ValidationRuleTypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ValidationRuleTypeEnum) || t == typeof(ValidationRuleTypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "max":
                    return ValidationRuleTypeEnum.Max;
                case "maxLength":
                    return ValidationRuleTypeEnum.MaxLength;
                case "min":
                    return ValidationRuleTypeEnum.Min;
                case "minLength":
                    return ValidationRuleTypeEnum.MinLength;
                case "require":
                    return ValidationRuleTypeEnum.Require;
            }
            throw new Exception("Cannot unmarshal type ValidationRuleTypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ValidationRuleTypeEnum)untypedValue;
            switch (value)
            {
                case ValidationRuleTypeEnum.Max:
                    serializer.Serialize(writer, "max");
                    return;
                case ValidationRuleTypeEnum.MaxLength:
                    serializer.Serialize(writer, "maxLength");
                    return;
                case ValidationRuleTypeEnum.Min:
                    serializer.Serialize(writer, "min");
                    return;
                case ValidationRuleTypeEnum.MinLength:
                    serializer.Serialize(writer, "minLength");
                    return;
                case ValidationRuleTypeEnum.Require:
                    serializer.Serialize(writer, "require");
                    return;
            }
            throw new Exception("Cannot marshal type ValidationRuleTypeEnum");
        }

        public static readonly ValidationRuleTypeEnumConverter Singleton = new ValidationRuleTypeEnumConverter();
    }

    internal class ValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Value) || t == typeof(Value?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Value { };
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Value { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Value { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Value)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }
}
